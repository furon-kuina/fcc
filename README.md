# fcc

### 2023/07/16
書き始めた。以前にも少しだけやったことがあるので序盤はスムーズに進む。

乗算を実装するところで詰まった。なぜか16*16が0になる。どうも結果が8ビットで表されているっぽい。
レジスタって基本64ビットじゃないの？
アセンブリは以下:
```
push 16
push 16
pop rdi
pop rax
imul rax, rdi
push rax
pop rax
ret
```

これはUNIXの終了コードが0-255の値しか取れないことが原因だった（よく見るとテキストに書いてある）。

### 2023/07/22
ファイルを分割するところで詰まっている。これまで1つのグローバル変数に持てたトークン列やASTを
どう処理するかが面倒。とりあえず雑に分割したらなぜかパースがうまくいかない。

具体的な問題は、`consume`や`expect`に`*Token`を渡すだけでは、それを進めてはくれないということ。
これまではグローバル変数を使っていたから問題なかったが、ファイルを分割するとそうはいかない。
結局、[chibiccのコミット](https://github.com/rui314/chibicc/commit/725badfb494544b7c7f1d4c4690b9bc033c6d051#diff-a0cb465674c1b01a07d361f25a0ef2b0214b7dfe9412b7777f89add956da10ec)を参考に、`**Token`を渡して進めてもらうようにした。
グローバル変数は嫌いなので、個人的にもこちらの設計のほうが好き。

よくよく考えると、`*Token`型の変数はそのトークンの情報と、次のトークンへのポインタしか持っておらず、「いまどこを見てるか」という情報は入ってない。その情報を与えるために`**Token`を渡す必要があるんだな。

参考にしたコードに`expr()`や`relational()`に`rest`を与える場合と`&tok`を与える場合があって
使い分けがよくわからなかった。

まず、それぞれの関数が何をしてるのかというと、適当にトークンを読んでASTのノードを作り、
`rest`を先に進めてくれてる。
これでようやく先に進める。
