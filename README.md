# fcc

### 2023/07/16
書き始めた。以前にも少しだけやったことがあるので序盤はスムーズに進む。

乗算を実装するところで詰まった。なぜか16*16が0になる。どうも結果が8ビットで表されているっぽい。
レジスタって基本64ビットじゃないの？
アセンブリは以下:
```
push 16
push 16
pop rdi
pop rax
imul rax, rdi
push rax
pop rax
ret
```

これはUNIXの終了コードが0-255の値しか取れないことが原因だった（よく見るとテキストに書いてある）。

### 2023/07/22
ファイルを分割するところで詰まっている。これまで1つのグローバル変数に持てたトークン列やASTを
どう処理するかが面倒。とりあえず雑に分割したらなぜかパースがうまくいかない。

具体的な問題は、`consume`や`expect`に`*Token`を渡すだけでは、それを進めてはくれないということ。
これまではグローバル変数を使っていたから問題なかったが、ファイルを分割するとそうはいかない。
結局、[chibiccのコミット](https://github.com/rui314/chibicc/commit/725badfb494544b7c7f1d4c4690b9bc033c6d051#diff-a0cb465674c1b01a07d361f25a0ef2b0214b7dfe9412b7777f89add956da10ec)を参考に、`**Token`を渡して進めてもらうようにした。

よくよく考えると、`*Token`型の変数はそのトークンの情報と、次のトークンへのポインタしか持っておらず、「いまどこを見てるか」という情報は入ってない。その情報を与えるために`**Token`を渡す必要があるんだな。

### 2023/07/23
ここまで実装して思ったが、`parse.c`でだけ使うグローバル変数`token`を導入して、
`parse()`の引数として渡したトークン列を`token`に代入してしまったほうが簡単。
そっちで行くことにした。chibiccのコードと乖離が生じるのは少し怖いが、考える機会になるだろう。
これでようやく先に進める。

### 2023/07/25
ローカル変数まで実装できた。
ちょっとスタックの動きが理解しきれてない部分がある。

### 2023/07/26
ローカル変数の再代入がうまくいかない。
そろそろデバッグ用のツールを整備したほうがいい気がしてきた。
欲しいのは
* トークナイズ結果の可視化（これは現状のprintで十分かも）
* パース結果のASTの可視化（これはどうやって作るのがいいんだろう）

### 2023/07/27
再代入でバグってるんじゃなくてその後のデバッグ用出力がバグってた……。
ASTの可視化を実装しようと思う。Graphvizを使うのがよさそう。
これは平日にやるのは無理だ。土日の課題とする。
今日はwhile文を実装しよう。

while文を実装するときに、`while(i < 10) i = i + 1;`のようなコードをテストしてみたら、
そもそも`i = i + 1`のような変数に変数を代入するコードがコンパイルできないことに気がついた。
これは変数の識別子をすべて`ND_LVAR`型のノードにパースしてるからで、
代入式の左右で扱いを変える必要がある。
スマートなやり方が思いつかない。グローバル変数を導入して左辺の状態


### 2023/07/29
`for`, `if`, `while`を実装した。
ちょっとコードの煩雑さが限界を超えつつある気がする。


### 2023/08/02
関数の呼び出しまで実装した。
テキストにはRSPを16の倍数に調整しろとあるが、まだ不具合は出てないので放置する。

### 2023/08/03
関数定義を実装した！
フィボナッチ数列が計算できるようになった！！！！
うれしい。

### 2023/08/05
ポインタを使えるようになった。
`int`や`int*`が現れるようになってぐっとCっぽくなってきた。
いまや下のようなコードがコンパイルできる。
```c
int f(int x) {
  if (x <= 2) {
    return 1;
  } else {
    return f(x - 1) + f(x - 2);
  }
}
int main() {
  return f(13);
}
```
```c
int main() {
  int x;
  int *y;
  int **z;
  y = &x;
  z = &y;
  **z = 5;
  return x;
}
```

### 2023/08/06
ポインタの加減算を実施した。
テストケースには別のCファイルで定義した下のような
関数をリンクして使っている。
```c
// 与えられたポインタの指す領域にメモリを確保する
int **alloc4(int **p, int a, int b, int c, int d) {
  *p = malloc(4 * sizeof(int));
  (*p)[0] = a;
  (*p)[1] = b;
  (*p)[2] = c;
  (*p)[3] = d;
  return p;
}
```
自分のコンパイラはまだ`int`もポインタも8バイトで
扱っているけど、上の`malloc`が4バイトでとってくれるため、
加減算のコードは`int`を4バイトとして扱っている。

`sizeof`を実装する段になって、いよいよ真面目に型と
向き合わないといけない気がしてきている。
関数の値の型ってどうやって調べればいいんだ？　関数ごとに返り値の型を
記録しておく？　chibiccはこの段階ではまだ関数の返り値が`int`であるとして
実装してるっぽい（つまり、`int *`を返す関数の返り値にsizeofを掛けると死ぬ（はず））。


### 2023/08/11
配列まで実装した。
配列は単項`&`と`sizeof`の引数になる以外はポインタに暗黙に型変換されるが、
その型変換をすべての箇所に記述するのは漏れが起きそうで怖い。
かといって、配列を見てるときには、それが`&`や`sizeof`の引数になるかは
わからないので、親ノードで変換を行うことは避けられない。
どうやったらいいだろう。

また、配列とポインタの違いとして、初期化が必要かどうかというのがある。
例えば
```c
int main() {
  int x;
  int *y;
  y = &x;
  *y = 2;
  return x;
}
```
というコードはコンパイルできたが、
```c
int main() {
  int a[2];
  *a = 2;
  return *a;
}
```
というコードはできなかった。
これは、前者では`y = &x`という初期化が陽に入っているが、後者では暗黙に
`a`の指すアドレスが指定されるからである。
本質的には、ポインタ型の変数にはポインタの指すアドレスが（整数として）
入っているが、配列型の変数ではメモリ上のどこにもそのアドレスが入っていないから、ということか。

これを解決するために、配列からポインタへの
変換はコードジェネレータで行うことにする。
こういう、変換をどこで行うかを変えることで状況が
簡単になるパターンはよく見る。

### 2023/08/12
作ったノードに型をつけるのを、今は手動でやっているが、
`new_node`が勝手に型をつけるようにしたい。

### 2023/08/13
C言語って関数の引数の評価順は定められていないのか……。

リファクタリング、どういう状態になるのがいいのか考えた結果、
一番上の関数は文法のパースだけを担当して、ノードの生成などは
別の関数にやらせるかたちがよさそう？

グローバル変数を実装するときに、
アセンブリの`.zero`と`.comm`の違いで詰まった。
Godboltは`.zero`を使っているが、なぜか自分の環境だと上手くいかない
（Godboltの出力をコピペしても動かない）
`objdump -h tmp`の出力を見ると若干メモリアロケーションに差があるので
そのあたりに原因があると思われるが、具体的な原因はよくわかっていない。

具体的なコードを残しておくと、
```c
x:
  .zero 4
main:
  mov DWORD PTR x[rip], 3
  mov eax, DWORD PTR x[rip]
  ret
```
はセグフォするが、
```
.comm x 4
main:
  mov DWORD PTR x[rip], 3
  mov eax, DWORD PTR x[rip]
  ret
```
は正しく動く。

多分原因がわかった。
Oracleの[x86 Assembly Language Reference Manual](https://docs.oracle.com/cd/E26502_01/html/E28388/eoiyg.html)
の`.zero`を見ると、"While filling a data section, the .zero directive fills the number of bytes specified by expression with zero (0)"とある。
つまり、data sectionを見ているときに`.zero`を入れないとうまく動いてくれない。
しかし、単純に上のassemblyを書くと、text sectionを作ってるときに
`.zero`を踏むので、ダメ。
`.data`を書いて指定するか、`.comm`でbss sectionに確保してもらうかしないといけない。