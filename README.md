# fcc

### 2023/07/16
書き始めた。以前にも少しだけやったことがあるので序盤はスムーズに進む。

乗算を実装するところで詰まった。なぜか16*16が0になる。どうも結果が8ビットで表されているっぽい。
レジスタって基本64ビットじゃないの？
アセンブリは以下:
```
push 16
push 16
pop rdi
pop rax
imul rax, rdi
push rax
pop rax
ret
```

これはUNIXの終了コードが0-255の値しか取れないことが原因だった（よく見るとテキストに書いてある）。

### 2023/07/22
ファイルを分割するところで詰まっている。これまで1つのグローバル変数に持てたトークン列やASTを
どう処理するかが面倒。とりあえず雑に分割したらなぜかパースがうまくいかない。

具体的な問題は、`consume`や`expect`に`*Token`を渡すだけでは、それを進めてはくれないということ。
これまではグローバル変数を使っていたから問題なかったが、ファイルを分割するとそうはいかない。
結局、[chibiccのコミット](https://github.com/rui314/chibicc/commit/725badfb494544b7c7f1d4c4690b9bc033c6d051#diff-a0cb465674c1b01a07d361f25a0ef2b0214b7dfe9412b7777f89add956da10ec)を参考に、`**Token`を渡して進めてもらうようにした。

よくよく考えると、`*Token`型の変数はそのトークンの情報と、次のトークンへのポインタしか持っておらず、「いまどこを見てるか」という情報は入ってない。その情報を与えるために`**Token`を渡す必要があるんだな。

### 2023/07/23
ここまで実装して思ったが、`parse.c`でだけ使うグローバル変数`token`を導入して、
`parse()`の引数として渡したトークン列を`token`に代入してしまったほうが簡単。
そっちで行くことにした。chibiccのコードと乖離が生じるのは少し怖いが、考える機会になるだろう。
これでようやく先に進める。

### 2023/07/25
ローカル変数まで実装できた。
ちょっとスタックの動きが理解しきれてない部分がある。

### 2023/07/26
ローカル変数の再代入がうまくいかない。
そろそろデバッグ用のツールを整備したほうがいい気がしてきた。
欲しいのは
* トークナイズ結果の可視化（これは現状のprintで十分かも）
* パース結果のASTの可視化（これはどうやって作るのがいいんだろう）

### 2023/07/27
再代入でバグってるんじゃなくてその後のデバッグ用出力がバグってた……。
ASTの可視化を実装しようと思う。Graphvizを使うのがよさそう。
これは平日にやるのは無理だ。土日の課題とする。
今日はwhile文を実装しよう。

while文を実装するときに、`while(i < 10) i = i + 1;`のようなコードをテストしてみたら、
そもそも`i = i + 1`のような変数に変数を代入するコードがコンパイルできないことに気がついた。
これは変数の識別子をすべて`ND_LVAR`型のノードにパースしてるからで、
代入式の左右で扱いを変える必要がある。
スマートなやり方が思いつかない。グローバル変数を導入して左辺の状態


### 2023/07/29
`for`, `if`, `while`を実装した。
ちょっとコードの煩雑さが限界を超えつつある気がする。


### 2023/08/02
関数の呼び出しまで実装した。
テキストにはRSPを16の倍数に調整しろとあるが、まだ不具合は出てないので放置する。

### 2023/08/03
関数定義を実装した！
フィボナッチ数列が計算できるようになった！！！！
うれしい。

### 2023/08/05
ポインタを使えるようになった。
`int`や`int*`が現れるようになってぐっとCっぽくなってきた。
いまや下のようなコードがコンパイルできる。
```c
int f(int x) {
  if (x <= 2) {
    return 1;
  } else {
    return f(x - 1) + f(x - 2);
  }
}
int main() {
  return f(13);
}
```
```c
int main() {
  int x;
  int *y;
  int **z;
  y = &x;
  z = &y;
  **z = 5;
  return x;
}
```